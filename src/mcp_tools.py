# â”€â”€â”€â”€â”€â”€â”€â”€â”€ mcp_tools.py â”€â”€â”€â”€â”€â”€â”€â”€â”€

import os
import json
import requests
import datetime
from google.oauth2.credentials import Credentials
from googleapiclient.discovery import build
from google.auth.transport.requests import Request

# â”€â”€ Google Calendar Helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

SCOPES           = ["https://www.googleapis.com/auth/calendar"]
CREDENTIALS_FILE = "credentials.json"
TOKEN_FILE       = "token.json"


def get_calendar_service():
    """
    Returns an authorized Google Calendar service object.
    Expects:
      - credentials.json (with client ID/secret) in the same folder
      - token.json (generated by oauth_setup.py) in the same folder

    Raises:
      Exception if token.json is missing or invalid.
    """
    # 1) Verify that credentials.json exists
    if not os.path.exists(CREDENTIALS_FILE):
        raise Exception(f"'{CREDENTIALS_FILE}' not found. Please create it from Google Cloud Console.")

    creds = None
    # 2) Load token.json if it exists
    if os.path.exists(TOKEN_FILE):
        creds = Credentials.from_authorized_user_file(TOKEN_FILE, SCOPES)

    # 3) If there are no (valid) credentials, attempt to refresh or raise
    if not creds or not creds.valid:
        if creds and creds.expired and creds.refresh_token:
            creds.refresh(Request())
        else:
            raise Exception(f"'{TOKEN_FILE}' missing or invalid. Run oauth_setup.py first.")

    # 4) Build the Calendar service
    service = build("calendar", "v3", credentials=creds)
    return service


def fetch_upcoming_events(max_results=5):
    """
    Fetch the next max_results events from the primary calendar, starting from 'now'.
    Returns a plain-text list, e.g.:
      - 2025-06-10T14:00:00-04:00: Team Meeting
      - 2025-06-11T09:30:00-04:00: Doctor Appointment

    If there are no future events, returns "You have no upcoming events."
    """
    service = get_calendar_service()

    # Use RFC3339 timestamp for 'now'
    now = datetime.datetime.utcnow().isoformat() + "Z"
    events_result = (
        service.events()
        .list(
            calendarId="primary",
            timeMin=now,
            maxResults=max_results,
            singleEvents=True,
            orderBy="startTime",
        )
        .execute()
    )
    events = events_result.get("items", [])

    if not events:
        return "You have no upcoming events."

    lines = []
    for event in events:
        # If it's a date-only event, 'date' will be present; otherwise 'dateTime'
        start = event["start"].get("dateTime", event["start"].get("date"))
        title = event.get("summary", "(No Title)")
        lines.append(f"- {start}: {title}")

    return "\n".join(lines)


def add_event_to_calendar(title, date, time):
    """
    Insert a new event into the userâ€™s primary calendar.
      - title: string, the eventâ€™s summary/title
      - date:  "YYYY-MM-DD"
      - time:  "HH:MM:SS" (24-hour)

    By default this will create a 1-hour event (you can adjust the duration logic if needed).
    Returns a confirmation string, e.g.:
      "Event 'Dentist Appointment' created for 2025-07-03T09:00:00."
    """
    service = get_calendar_service()

    # Construct start and end in RFC3339 form
    dt_start = f"{date}T{time}"
    hh, mm, ss = time.split(":")
    # End one hour later (wraps properly if you cross midnight? It just increments hour; if 23 -> 24, Google will adjust)
    end_hour = int(hh) + 1
    end_hour_str = f"{end_hour:02d}"
    dt_end = f"{date}T{end_hour_str}:{mm}:{ss}"

    event_body = {
        "summary": title,
        "start": {"dateTime": dt_start, "timeZone": "America/New_York"},
        "end":   {"dateTime": dt_end,   "timeZone": "America/New_York"},
    }

    created = service.events().insert(calendarId="primary", body=event_body).execute()
    return f"Event '{title}' created for {dt_start}."


# â”€â”€ To-Do List Helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

TODO_FILE = "todo.json"


def load_todo_list():
    """
    Returns a list of to-do items (each item is a dict {"item": <string>}), or [] if none.
    If the JSON is malformed, returns [].
    """
    if not os.path.exists(TODO_FILE):
        return []
    with open(TODO_FILE, "r") as f:
        try:
            data = json.load(f)
            return data if isinstance(data, list) else []
        except json.JSONDecodeError:
            return []


def save_todo_list(tasks):
    """
    Overwrite TODO_FILE with the given list of tasks.
    Each task should be a dict: {"item": <string>}.
    """
    with open(TODO_FILE, "w") as f:
        json.dump(tasks, f, indent=2)


def manage_todo_list(action, item=None):
    """
    action: "add", "remove", or "list"
    item:   string (only needed if action is "add" or "remove")

    Returns a plain-text result.
    """
    tasks = load_todo_list()

    if action == "add":
        if not item:
            return "Error: No item provided for 'add'."
        for t in tasks:
            if t.get("item", "").lower() == item.lower():
                return f"'{item}' is already in your to-do list."
        tasks.append({"item": item})
        save_todo_list(tasks)
        return f"Added '{item}' to your to-do list."

    if action == "remove":
        if not item:
            return "Error: No item provided for 'remove'."
        filtered = [t for t in tasks if t.get("item", "").lower() != item.lower()]
        if len(filtered) == len(tasks):
            return f"'{item}' not found in your to-do list."
        save_todo_list(filtered)
        return f"Removed '{item}' from your to-do list."

    if action == "list":
        if not tasks:
            return "Your to-do list is empty."
        lines = [f"- {t['item']}" for t in tasks]
        return "Your to-do list:\n" + "\n".join(lines)

    return f"Unsupported action '{action}'. Use 'add', 'remove', or 'list'."


# â”€â”€ Weather Helper â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

def check_weather(location):
    """
    Fetch a one-line weather summary from wttr.in (no API key needed).
    For example, "London: ðŸŒ¦ +15Â°C"
    If there is an error, returns an appropriate message.
    """
    try:
        resp = requests.get(f"http://wttr.in/{location}?format=3", timeout=5)
        if resp.status_code == 200:
            return resp.text.strip()
        return f"Could not fetch weather for '{location}'."
    except Exception as e:
        return f"Error fetching weather: {e}"


# â”€â”€ Free Maps Helper (OpenStreetMap / Nominatim) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

def get_map(location):
    """
    Use OpenStreetMapâ€™s Nominatim to geocode a place name (free).
    Returns: "Coordinates for '<location>': <lat>, <lon>\nOpenStreetMap link: <URL>"
    If no results or an error, returns an appropriate message.
    """
    headers = {"User-Agent": "mcp-server/1.0 (you@example.com)"}
    params  = {"q": location, "format": "json", "limit": 1}

    try:
        resp = requests.get("https://nominatim.openstreetmap.org/search", params=params, headers=headers, timeout=5)
        if resp.status_code != 200:
            return f"Could not fetch map data for '{location}'."
        data = resp.json()
        if not data:
            return f"No results found for '{location}'."

        lat = data[0]["lat"]
        lon = data[0]["lon"]
        osm_link = f"https://www.openstreetmap.org/?mlat={lat}&mlon={lon}&zoom=14"
        return f"Coordinates for '{location}': {lat}, {lon}\nOpenStreetMap link: {osm_link}"

    except Exception as e:
        return f"Error fetching map data: {e}"
